# Cheeting Sheet

2024/6/5 王昊21光华

## 工具

char.isalpha()：判断是否是字母；char.isnumeric()：判断是否只包含数字；char.isupper()/islower()：判断大小写

int(str,n)

for key,value in dict.items()

for index,value in enumerate(list)

dict.get(key,default)

list(zip(a,b))

math.pow(m,n)

math.log(m,n)

```python
from functools import lru_cache
@lru_cache(maxsize=None)
```

1. `str.lstrip() / str.rstrip()`: 移除字符串左侧/右侧的空白字符。
2. `str.find(sub)`: 返回子字符串`sub`在字符串中首次出现的索引，如果未找到，则返回-1。
3. `str.replace(old, new)`: 将字符串中的`old`子字符串替换为`new`。
4. `str.startswith(prefix) / str.endswith(suffix)`: 检查字符串是否以`prefix`开头或以`suffix`结尾。
5. `str.isalpha() / str.isdigit() / str.isalnum()`: 检查字符串是否全部由字母/数字/字母和数字组成。

calendar

1. `calendar.month(年, 月)`: 返回一个月份的日历字符串。它接受年份和月份作为参数，并以多行字符串的形式返回该月份的日历。
2. `calendar.calendar(年)`: 返回一个年份的日历字符串。这个函数生成整个年份的日历，格式化为多行字符串。
3. `calendar.monthrange(年, 月)`: 返回两个整数，第一个是该月第一天是周几（0-6表示周一到周日），第二个是该月的天数。
4. `calendar.weekday(年, 月, 日)`: 返回给定日期是星期几。0-6的返回值分别代表星期一到星期日。
5. `calendar.isleap(年)`: 返回一个布尔值，指示指定的年份是否是闰年。
6. `calendar.leapdays(年1, 年2)`: 返回在指定范围内的闰年数量，不包括第二个年份。
7. `calendar.monthcalendar(年, 月)`: 返回一个整数矩阵，表示指定月份的日历。每个子列表表示一个星期；天数为0表示该月份此天不在该星期内。
8. `calendar.setfirstweekday(星期)`: 设置日历每周的起始日。默认情况下，第一天是星期一，但可以通过这个函数更改。
9. `calendar.firstweekday()`: 返回当前设置的每周起始日。

counter：计数

```python
from collections import Counter
a=['red', 'blue', 'red', 'green', 'blue', 'blue']
a=Counter(a)
```

permutations：全排列

```python
from itertools import permutations as per
elements = [1, 2, 3]
permutations = list(per(elements))
```

combinations：组合

```python
from itertools import combinations as com
elements = ['A', 'B', 'C', 'D']
# 生成所有长度为2的组合
combinations = list(com(elements, 2))
```

bisect

```python
import bisect
# 创建一个已排序的列表
sorted_list = [1, 3, 3, 6, 7, 9]
# 使用 bisect_left 查找元素应插入的位置
insert_index = bisect.bisect_left(sorted_list, 4)
print("Insert at index:", insert_index)
# 使用 insort_left 插入元素并保持有序
bisect.insort_left(sorted_list, 4)
print("Updated list:", sorted_list)
```

reduce：累积

```python
import functools
numbers = [1, 2, 3, 4, 5]
# 使用 reduce 计算累积乘积
product = functools.reduce(lambda x, y: x * y, numbers)
```

product：笛卡尔积

```python
from itertools import product
# 创建两个可迭代对象
colors = ['red', 'blue']
numbers = [1, 2]
# 生成它们的笛卡尔积
cartesian_product = list(product(colors, numbers))
# 创建一个可迭代对象
colors = ['red', 'blue']
# 生成它们的重复笛卡尔积
repeat_cartesian_product = list(product(colors, repeat=3))
```

## 排序

逆序对

```python
def ReversePairs(arr):
    def sort(arr, l, r, temp):
        res = 0
        if l < r:
            mid = l + (r - l) // 2
            res += sort(arr, l, mid, temp)
            res += sort(arr, mid + 1, r, temp)
            if arr[mid] > arr[mid + 1]:
                res += merge(arr, l, mid, r, temp)
        return res

    def merge(arr, l, mid, r, temp):
        temp[l:r + 1] = arr[l:r + 1]
        i = l
        j = mid + 1
        res = 0
        for k in range(l, r + 1):
            if i > mid:
                arr[k] = temp[j]
                j += 1
            elif j > r:
                arr[k] = temp[i]
                i += 1
            elif temp[i] <= temp[j]:
                arr[k] = temp[i]
                i += 1
            else:
                arr[k] = temp[j]
                j += 1
                res += mid - i + 1
        return res

    temp = arr * 1
    return sort(arr, 0, len(arr) - 1, temp)
```

# 滑动窗口

最小覆盖字串

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        ans_left, ans_right = -1, len(s)
        left = 0
        cnt_s = Counter()
        cnt_t = Counter(t)
        for right, c in enumerate(s):
            cnt_s[c] += 1
            while cnt_s >= cnt_t:
                if right - left < ans_right - ans_left:
                    ans_left, ans_right = left, right
                cnt_s[s[left]] -= 1
                left += 1
        return "" if ans_left < 0 else s[ans_left: ans_right + 1]
```



## 栈

中序转后序

```python
def infix_to_postfix(expression):
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}
    stack = []
    postfix = []
    number = ''
	
    for char in expression:
        if char.isnumeric() or char == '.':
            number += char
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:
                    postfix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()

    if number:
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)

    while stack:
        postfix.append(stack.pop())

    return ' '.join(str(x) for x in postfix)
```

动态中位数

```python
for _ in range(int(input())):
    q1, q2, cur, cnt = [], [], [], 0
    for i in list(map(int, input().split())):
        cnt += 1
        if not q1:
            heappush(q1, -i)
        elif i >= -q1[0]:
            heappush(q2, i)
        else:
            heappush(q1, -i)
        while len(q2) > len(q1):
            tmp = heappop(q2)
            heappush(q1, -tmp)
        while len(q1) > len(q2) + 1:
            tmp = -heappop(q1)
            heappush(q2, tmp)
        if cnt % 2:
            cur.append(str(-q1[0]))
```

# 单调栈

奶牛排队

```python
from bisect import bisect_right

lst, q1, q2, ans = [int(input())for _ in range(int(input()))], [-1], [-1], 0
for i in range(len(lst)):
    while len(q1) > 1 and lst[q1[-1]] >= lst[i]:
        q1.pop()
    while len(q2) > 1 and lst[q2[-1]] < lst[i]:
        q2.pop()
    id = bisect_right(q1, q2[-1])
    if id < len(q1):
        ans = max(ans, i - q1[id] + 1)
    q1.append(i)
    q2.append(i)
```

接雨水

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

柱状图中的最大矩形

```python
def largestRectangleArea(self, heights):
    n = len(heights)
    left, right = [0] * n, [0] * n
    mono_stack = list()
    for i in range(n):
        while mono_stack and heights[mono_stack[-1]] >= heights[i]:
            mono_stack.pop()
        left[i] = mono_stack[-1] if mono_stack else -1
        mono_stack.append(i)
    mono_stack = list()
    for i in range(n - 1, -1, -1):
        while mono_stack and heights[mono_stack[-1]] >= heights[i]:
            mono_stack.pop()
        right[i] = mono_stack[-1] if mono_stack else n
        mono_stack.append(i)
    ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0
    return ans
```

车队

```python
def getCollisionTimes(self, cars):
    n = len(cars)
    ans = [-1.0] * n
    stack = []
    for i in range(n - 1, -1, -1):
        pos, speed = cars[i]
        while stack and speed <= cars[stack[-1]][1]:
            stack.pop()
        while stack:
            j = stack[-1]
            time = (cars[j][0] - pos) / (speed - cars[j][1])
            if ans[j] < 0 or time <= ans[j]:
                ans[i] = time
                break
            stack.pop()
        stack.append(i)
    return ans
```

## 二分搜索

河中跳房子

```python
def check(x):
    num = 0
    now = 0
    for i in range(1, n + 2):
        if rock[i] - now < x:
            num += 1
        else:
            now = rock[i]
    if num > m:
        return True
    else:
        return False
lo, hi = 0, L + 1
ans = -1
while lo < hi:
    mid = (lo + hi) // 2
    if check(mid):
        hi = mid
    else:
        ans = mid
        lo = mid + 1
```

两个有序序列中位数

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def getKthElement(k):
            index1, index2 = 0, 0
            while True:
                if index1 == m:
                    return nums2[index2 + k - 1]
                if index2 == n:
                    return nums1[index1 + k - 1]
                if k == 1:
                    return min(nums1[index1], nums2[index2])
				
                newIndex1 = min(index1 + k // 2 - 1, m - 1)
                newIndex2 = min(index2 + k // 2 - 1, n - 1)
                pivot1, pivot2 = nums1[newIndex1], nums2[newIndex2]
                if pivot1 <= pivot2:
                    k -= newIndex1 - index1 + 1
                    index1 = newIndex1 + 1
                else:
                    k -= newIndex2 - index2 + 1
                    index2 = newIndex2 + 1

                    m, n = len(nums1), len(nums2)
                    totalLength = m + n
                    if totalLength % 2 == 1:
                        return getKthElement((totalLength + 1) // 2)
                    else:
                        return (getKthElement(totalLength // 2) + getKthElement(totalLength // 2 + 1)) / 2
```

# dp

核电站

```python
# 有最长连续长度限制的放置问题
dp=[0]*(n+1)
dp[0]=1
for i in range(1,n+1):
    if i<m:
        dp[i]=dp[i-1]*2
    elif i==m:
        dp[i]=dp[i-1]*2-1
    else:
        dp[i]=dp[i-1]*2-dp[i-m-1]
print(dp[n])
```

全为1正方形矩阵

```python
m, n = map(int, input().split())
mat = [[int(k) for k in input()] for i in range(m)]
dp = [[0 for j in range(n+1)] for i in range(m+1)]
for i in range(m):
    for j in range(n):
        if mat[i][j]:
            dp[i+1][j+1] = min(dp[i][j], dp[i][j+1], dp[i+1][j])+1
print(sum(dp[i][j] for j in range(n+1) for i in range(m+1)))
```

最长公共子序列

```python
dp = [[0] * (n + 1) for _ in range(m + 1)]
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if x[i - 1] == y[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
print(dp[m][n])
```

flowers(474D)

```python
# 成组放置问题
dp=[0]*100001
dp[0]=1
for i in range(1,100001):
    dp[i]=dp[i-1]
    if i>=k:
        dp[i]=(dp[i]+dp[i-k])%MOD
for i in range(1,100001):
    dp[i]=(dp[i]+dp[i-1])%MOD
print((dp[b]-dp[a-1]+MOD)%MOD)
```

k-tree（CF431C）

```python
# 有序的整数划分问题
A = [1] + [0] * n
B = [1] + [0] * n
for i in range(1, n + 1):
    for j in range(1, min(i,k)+1):
        A[i] = (A[i] + A[i - j]) % mod
    for j in range(1, min(d, i + 1)):
        B[i] = (B[i] + B[i - j]) % mod
print((A[n] - B[n]) % mod)
```

宠物小精灵之收服

```python
# 双限制背包问题
# dp[i][j]为捕获i个小精灵，皮卡丘剩余j体力时，剩余的最大精灵球数量
dp=[[-1]*(m+1) for _ in range(k+1)]
dp[0][m]=n
for i in range(k):
    cost,harm=map(int,input().split())
    for blood in range(m):
        for catch in range(i+1):
            pre_blood=blood+harm
            if pre_blood<=m and dp[catch][pre_blood]!=-1:
                dp[catch+1][blood]=max(dp[catch+1][blood],dp[catch][pre_blood]-cost)
for i in range(k,-1,-1):
    for j in range(m,-1,-1):
        if dp[i][j]!=-1:
            print(i,j)
            exit()
```

最佳凑单

```python
# 稀疏桶
a,b=map(int,input().split());c={0}
for i in map(int,input().split()):
    for j in c.copy():
        if j<b:c.add(i+j)
for i in sorted(c):
    if i>=b:print(i);exit()
print(0)
```

piggy-bank

```python
# 完全背包中的最优解问题
dp = [float('inf')] * (n + 1)
dp[0] = 0
for i in range(m):
    for j in range(w[i], n + 1):
        dp[j] = min(dp[j], dp[j - w[i]] + v[i])
if dp[n] == float('inf'):
    print('This is impossible.')
else:
    print(f'The minimum amount of money in the piggy-bank is {dp[n]}.')
```

coins

```python
# 多重背包中的方案数问题
dp = [0] * (m + 1)
dp[0] = 1
for i in range(n):
    coin, count = value[i], counts[i]
    for j in range(count):
        for v in range(m, coin - 1, -1):
            dp[v] += dp[v - coin]
print(sum(1 for x in dp[1:] if x > 0))
```

```python
# 二进制&位运算优化
dp = 1  # 初始化为只有第0位为1的整数，表示初始时只有0这个和是可以达到的
    mask = (1 << (m + 1)) - 1  # 创建一个掩码，用于限制dp的长度
    for value, count in zip(values, counts):
        while count:
            k = 1
            while k <= count:  # 找到不超过count的最大2的幂
                dp = (dp | (dp << (value * k))) & mask
                count -= k
                k <<= 1
    print(bin(dp).count('1') - 1)
```

NBA门票

```python
# 多重背包中的最优解问题
dp=[float('inf')]*(n+1)
dp[0]=0
for i in range(6,-1,-1):
    cur=price[i]
    for k in range(n,cur-1,-1):
        for j in range(1,nums[i]+1):
            if k>=cur*j:
                dp[k]=min(dp[k],dp[k-cur*j]+j)
            else:
                break
if dp[-1]==float('inf'):
    print('Fail')
else:
    print(dp[-1])
```

```python
# 二进制优化
dp = [float('inf')] * (n + 1)
dp[0] = 0
for i in range(7):
    cur_price = price[i]
    cur_num = nums[i]
    k = 1
    while cur_num > 0:
        use_num = min(cur_num, k)
        cur_num -= use_num
        for j in range(n, cur_price * use_num - 1, -1):
            dp[j] = min(dp[j], dp[j - cur_price * use_num] + use_num)
        k *= 2
if dp[-1] == float('inf'):
    print('Fail')
else:
    print(dp[-1])
```

神奇的口袋

```python
# 0-1背包中的方案数问题
dp=[0]*(41)
dp[0]=1
for item in items:
    for volume in range(40,item-1,-1):
        dp[volume]+=dp[volume-item]
print(dp[40])
```

采药

```python
# 0-1背包中的最优解问题
dp=[-1]*(T+1)
dp[0]=0
for _ in range(m):
    t,v=map(int,input().split())
    for i in range(T,t-1,-1):
        if dp[i-t]!=-1:
            dp[i]=max(dp[i],dp[i-t]+v)
print(max(dp))
```

复杂的整数划分问题

```python
# N划分成K个正整数之和
def divide_k(n,k):
    dp=[[0]*(k+1) for _ in range(n+1)]
    for i in range(n+1):
        dp[i][1]=1
    for i in range(1,n+1):
        for j in range(1,k+1):
            if i>=j:
                # dp[i-1][j-1]为包含1的划分的数量
                # 若不包含1，我们对每个数-1仍为正整数，划分数量为dp[i-j][j]
                dp[i][j]=dp[i-j][j]+dp[i-1][j-1]
    return dp[n][k]
# N划分成若干个不同正整数之和
def divide_dif(n):
    # dp[i][j]表示将数字 i 划分，其中最大的数字不大于 j 的方法数量
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if i < j:
                dp[i][j] = dp[i][i]
            elif i == j:
                dp[i][j] = dp[i][j - 1] + 1
            # 用/不用j
            else:
                dp[i][j] = dp[i][j - 1] + dp[i - j][j - 1]
    return dp[n][n]
```

世界杯只因

```python
# 区间覆盖问题
dp=[1<<30]*(n+1)
dp[0]=0
for i in range(n):
    l=max(1,i+1-a[i])
    r=min(n,i+1+a[i])
    if dp[r]>dp[l-1]+1:
        for j in range(l,r+1):
            dp[j]=min(dp[j],dp[l-1]+1)
print(dp[-1])
```

# greedy

跳跃游戏

```python
def jump(self, nums: List[int]) -> int:
    n = len(nums)
    maxPos, end, step = 0, 0, 0
    for i in range(n - 1):
        if maxPos >= i:
            maxPos = max(maxPos, i + nums[i])
            if i == end:
                end = maxPos
                step += 1
    return step
```

holiday hotel

```python
# 筛选问题
hotels=[tuple(map(int,input().split())) for _ in range(n)]
hotels.sort(key=lambda x:(x[0],x[1]))
candidates=1
max_cost_so_far=hotels[0][1]
for i in range(n):
    if hotels[i][1]<max_cost_so_far:
        candidates+=1
        max_cost_so_far=hotels[i][1]
print(candidates)
```

expedition

```python
# 加油问题
stations.sort() # 按距离升序
stations.append((L, 0) # 添加起点
pq = []  # 最大堆
stops, prev, fuel = 0, 0, P
for location, capacity in stations:
    fuel -= location - prev
    while pq and fuel < 0:  # 当前燃料不够到达下一加油站
        fuel += -heapq.heappop(pq)  # 选择提供最多燃料的加油站加油
        stops += 1
    if fuel < 0: print(-1) ;exit()  # 无法到达下一个加油站或终点
    heapq.heappush(pq, -capacity)
    prev = location
print(stops)
```

畜栏保留问题

```python
# 时间调度问题
# cows元素：（index，start, end）
cows.sort(key=lambda x:x[1])
space=[]
space_num=[0]*n
max_num=1
for cow in cows:
    if space:
        if space[0][0]<cow[1]:
            space_num[cow[0]]=space_num[space[0][1]]
            heappop(space)
        else:
            space_num[cow[0]]=max_num+1
            max_num+=1
    else:
        space_num[cow[0]]=1
    heappush(space,(cow[2],cow[0],cow[1]))
print(len(space))
for num in space_num:
    print(num)
```

建筑修建

```python
# 区间调度问题
def generate(x,w):
    for i in range(max(0,x-w+1),min(x,m-w)+1):
        a.append((i,i+w))
n,m=map(int,input().split())
a=[]
for _ in range(n):
    x,w=map(int,input().split())
    generate(x,w)
a.sort(key=lambda x:x[1])
ans=0;end=0
for i in a:
    if i[0]>=end:
        ans+=1;end=i[1]
print(ans)
```

wooden sticks

```python
# 单调子列的最小拆分数
data=list(zip(data[0::2],data[1::2]))
data.sort(key=lambda x:(x[0],x[1]))
flag=[False]*n
cnt=0
for i in range(n):
    if flag[i]:
        continue
    cur=data[i][1]
    cnt+=1
    for j in range(i,n):
        if flag[j]==False and data[j][1]>=cur:
            flag[j]=True
            cur=data[j][1]
print(cnt)
```

potions(CF1526C1)

```python
# 对前缀和限制的最多选择问题
total_health = 0
min_heap = []
for health_change in health_changes:
    heapq.heappush(min_heap, health_change)
    total_health += health_change
    if total_health < 0:
        total_health -= heapq.heappop(min_heap)
potions_drank = len(min_heap)
print(potions_drank)
```

# 遍历

分发糖果

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        left = [0] * n
        for i in range(n):
            if i > 0 and ratings[i] > ratings[i - 1]:
                left[i] = left[i - 1] + 1
            else:
                left[i] = 1
        
        right = ret = 0
        for i in range(n - 1, -1, -1):
            if i < n - 1 and ratings[i] > ratings[i + 1]:
                right += 1
            else:
                right = 1
            ret += max(left[i], right)
        
        return ret
```

三数之和

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        nums.sort()
        ans = list()
        for first in range(n):
            if first > 0 and nums[first] == nums[first - 1]:
                continue
            third = n - 1
            target = -nums[first]
            for second in range(first + 1, n):
                if second > first + 1 and nums[second] == nums[second - 1]:
                    continue
                while second < third and nums[second] + nums[third] > target:
                    third -= 1
                if second == third:
                    break
                if nums[second] + nums[third] == target:
                    ans.append([nums[first], nums[second], nums[third]])
        
        return ans
```



# 技巧型

分解因数

```python
def decompositions(n,minfactor):
    if n==1:
        return 1
    count=0
    for i in range(minfactor,n+1):
        if n%i==0:
            count+=decompositions(n//i,i)
    return count
print(decompositions(x,2))
```

四数之和

```python
from collections import Counter
from itertools import product
N = int(input())
A, B, C, D = [], [], [], []
for i in range(N):
    a, b, c, d = map(int, input().split())
    A.append(a)
    B.append(b)
    C.append(c)
    D.append(d)
ab_sum_counter = Counter(map(sum, product(A, B)))
count = 0
for cd_sum in map(sum, product(C, D)):
    count += ab_sum_counter.get(-cd_sum, 0)
print(count)
```

最短前缀

```python
# 字典树
def insert(root, word):
    # 将单词插入字典树
    node = root
    for char in word:
        if char not in node:
            node[char] = {}  # 如果字符不存在，则在当前节点下创建一个新节点
        node = node[char]   # 移动到下一个节点
        node['count'] = node.get('count', 0) + 1  # 更新节点上的计数
def find_prefix(root, word):
    # 在字典树中为单词找到独特的最短前缀
    node = root
    prefix = ""
    for char in word:
        if node[char].get('count', 1) == 1:
            return prefix + char  # 如果该节点的计数为1，则返回当前前缀加上该字符
        prefix += char  # 否则，将字符添加到前缀中
        node = node[char]  # 继续遍历下一个字符
    return prefix
root = {}
for word in words:
    insert(root, word)
for word in words:
    prefix = find_prefix(root, word)
    print(f"{word} {prefix}")
```

假币问题

```python
# 集合运算
for _ in range(3):
    left,right,judge=input().split()
    left,right=set(left),set(right)
    if judge=='even':
        even.append(left|right)  # 并
    elif judge=='up':
        if len(heavy)!=0:heavy&=left;light&=right # 交
        else:heavy=left;light=right
    else:
        if len(heavy)!=0:heavy&=right;light&=left
        else:heavy=right;light=left
for i in even:
    light-=i;heavy-=i  # 差
```

最小新整数

```python
# 单调栈
def removeKDigits(num, k):
    stack = []
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    # 如果还未删除k位，从尾部继续删除
    while k:
        stack.pop()
        k -= 1
    return int(''.join(stack))
```

护林员盖房子

```python
# 寻找最大全0子矩阵
# 单调栈
for row in ma:
    stack=[]
    for i in range(n):
        h[i]=h[i]+1 if row[i]==0 else 0
        while stack and h[stack[-1]]>h[i]:
            y=h[stack.pop()]
            w=i if not stack else i-stack[-1]-1
            ans=max(ans,y*w)
        stack.append(i)
    while stack:
        y=h[stack.pop()]
        w=n if not stack else n-stack[-1]-1
        ans=max(ans,y*w)
print(ans)
```

number of ways

```python
n=int(input())
nums=list(map(int,input().split()))
s=sum(nums)
if s%3!=0:
    print(0)
    exit()
s=s//3
ans,cnt,pre_sum=0,0,0
for i in range(n-1):
    pre_sum+=nums[i]
    if pre_sum==s*2:
        ans+=cnt
    if pre_sum==s:
        cnt+=1
print(ans)
```

查找最接近的元素

```python
# bisect库
from bisect import bisect_left
def find_closest(arr, target):
    n = len(arr)
    if target <= arr[0]:
        return arr[0]
    if target >= arr[n-1]:
        return arr[n-1]
    pos = bisect_left(arr, target)
    if (arr[pos] - target) < (target - arr[pos - 1]):
        return arr[pos]
    else:
        return arr[pos - 1]
```

consecutive subsequence(CF977F)

```python
# seq_len中value为以key结尾的consecutive subsequence最大长度
seq_len = {}
max_len = 0
for num in nums:
    seq_len[num] = seq_len.get(num - 1, 0) + 1
    if seq_len[num]>max_len:
        max_len=seq_len[num]
        end=num
indices = []
# 从end开始回溯路径
for i in range(n,0,-1):
    if nums[i - 1] == end:
        indices.append(i)
        end -= 1
    if end == 0:
        break
print(max_len)
print(*indices[::-1])
```

最大子矩阵

```python
def max_submatrix(matrix):
    def kadane(arr):
        max_end_here = max_so_far = arr[0]
        for x in arr[1:]:
            max_end_here = max(x, max_end_here + x)
            max_so_far = max(max_so_far, max_end_here)
        return max_so_far

    rows = len(matrix)
    cols = len(matrix[0])
    max_sum = float('-inf')

    for left in range(cols):
        temp = [0] * rows
        for right in range(left, cols):
            for row in range(rows):
                temp[row] += matrix[row][right]
            max_sum = max(max_sum, kadane(temp))
    return max_sum
```

完美的爱

```python
from collections import defaultdict
dic=defaultdict(list)
data=[0]+data
ans=0
for i in range(1,n+1):
    # 构造一个减去了520i的前缀和
    # 使得有相同前缀和的位置间即为满足题意的区间
    data[i]+=data[i-1]-520
for i in range(n+1):
    dic[data[i]].append(i)
for i in dic:
    ans=max(ans,max(dic[i])-min(dic[i]))
print(ans*520)
```

Kefa and company(CF580B)

```python
# 对滑动窗口内某变量极差限制的最优解问题
friends.sort()
ans=cur=left=0
for right in range(n):
    cur+=friends[right][1]
    while friends[right][0]-friends[left][0]>=d:
        cur-=friends[left][1]
        left+=1
    ans=max(ans,cur)
print(ans)
```

in love

```python
# dict+heapq实现最值更新的效率提升
from heapq import heappop,heappush
from collections import defaultdict
q = int(input())
ldict, rdict = defaultdict(int), defaultdict(int)
pq_l, pq_r = [], []
for _ in range(q):
    op, l, r = map(str, input().split())
    l, r = int(l), int(r)
    if op == "+":
        ldict[l] += 1; rdict[r] += 1
        heappush(pq_l, -l); heappush(pq_r, r)
    if op == "-":
        ldict[l] -= 1; rdict[r] -= 1
    while len(pq_l) > 0 >= ldict[-pq_l[0]]:
        heappop(pq_l)
    while len(pq_r) > 0 >= rdict[pq_r[0]]:
        heappop(pq_r)
    if len(pq_l) > 0 and pq_r[0] < -pq_l[0]:
        print("Yes")
    else: print("No")
```

cat party

```python
# 桶套桶实现时间复杂度的降低
from collections import defaultdict
n = int(input())
a = list(map(int, input().split()))
cc = defaultdict(int)  # color count
fc = defaultdict(int)  # frequency count
ans = 0
for i in range(n):
    c = a[i]
    if cc[c] in fc:
        fc[cc[c]] -= 1
        if fc[cc[c]] == 0:
            del fc[cc[c]]
    cc[c] += 1
    fc[cc[c]] += 1
    if len(fc) == 1 and (1 in fc or list(fc.values())[0] == 1):
        ans = i + 1
    elif len(fc) == 2:
        k = sorted(fc.keys())
        if k[0] + 1 == k[1] and fc[k[1]] == 1 or k[0] == 1 and fc[k[0]] == 1:
            ans = i + 1
print(ans)
```

最大点数（外太空2048）

```python
# 矩阵的翻转与转置应用
from copy import deepcopy
def slide(ma,dir,step):
    if step==p:return max([max(i) for i in ma])
    cur=deepcopy(ma)
    if dir[1]:cur=list(zip(*cur))
    if dir[0]:cur=[i[::-1] for i in cur]
    for j in range(len(cur)):
        line=cur[j]
        k=len(line)
        line=[i for i in line if i!=0]
        i=len(line)-2
        while i>=0:
            if line[i+1]==line[i]:
                line[i]*=2
                del line[i+1]
            i-=1
        cur[j]=line+[0]*(k-len(line))
    if dir[0]:cur=[i[::-1] for i in cur]
    if dir[1]:cur=list(zip(*cur))
    ans=0
    for i in [0,1]:
        for j in [0,1]:
            ans=max(ans,slide(cur,(i,j),step+1))
    return ans
m,n,p=map(int,input().split())
ma=[list(map(int,input().split())) for _ in range(m)]
res=0
for i in [0,1]:
    for j in [0,1]:
        res=max(res,slide(ma,(i,j),0))
print(res)
```

# bfs/dfs

棋盘问题

```python
# 回溯法
def dfs(row, k):
    if k == 0:
        return 1
    if row == n:
        return 0
    count = 0
    for col in range(n):
        if board[row][col] == '#' and not col_occupied[col]:
            col_occupied[col] = True
            count += dfs(row + 1, k - 1)
            col_occupied[col] = False
    count += dfs(row + 1, k)
    return count
col_occupied = [False] * n
print(dfs(0, k))
```

迷宫问题

```python
# 要求输出路径的问题  
queue = deque([((0, 0), [])])  
while queue:
    (x, y), path = queue.popleft()
    if (x, y) == (n - 1, m - 1):  
        return path + [(x, y)]
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == 0:
            visited[nx][ny] = True
            queue.append(((nx, ny), path + [(x, y)]))
return []  
```

滑雪

```python
# 记忆化搜索
from functools import lru_cache
@lru_cache(maxsize=None)
def dfs(x,y):
    ans=0
    for dx,dy in dir:
        nx,ny=x+dx,y+dy
        if 0<=nx<m and 0<=ny<n and h[nx][ny]<h[x][y]:
            ans=max(ans,dfs(nx,ny)+1)
    return ans
m,n=map(int,input().split())
h=[list(map(int,input().split())) for _ in range(m)]
dir=[(0,1),(1,0),(-1,0),(0,-1)]
res=0
for i in range(m):
    for j in range(n):
        res=max(res,dfs(i,j))
print(res+1)
```

小游戏

```python
# heap+bfs
from heapq import heappop,heappush
from copy import deepcopy
def bfs(i,j):
    vis=set();q=[(0,-1,i,j)]
    while q:
        cnt,d,x,y=heappop(q)
        vis.add((x,y))
        if x==x2 and y==y2:return cnt
        for i in range(4):
            dx,dy=dir[i];nx,ny=x+dx,y+dy
            if 0<=nx<h+2 and 0<=ny<w+2 and\
                temp[nx][ny]==' ' and (nx,ny) not in vis:
                if i==d:heappush(q,(cnt,i,nx,ny))
                else:heappush(q,(cnt+1,i,nx,ny))
    return -1
dir=[(-1,0),(1,0),(0,1),(0,-1)]
board=0
while True:
    w,h=map(int,input().split())
    if w==0:break
    board+=1
    print(f'Board #{board}:')
    pair=0
    ma=[[' ']*(w+2)]
    for _ in range(h):
        ma.append([' ']+list(input())+[' '])
    ma.append([' ']*(w+2))
    while True:
        y1,x1,y2,x2=map(int,input().split())
        if y1==0:break
        pair+=1
        temp=deepcopy(ma)
        temp[x2][y2]=' '
        ans=bfs(x1,y1)
        if ans==-1:print(f'Pair {pair}: impossible.')
        else:print(f'Pair {pair}: {ans} segments.')
    print()
```

变换的迷宫

```python
# 三维visited
from collections import deque
def bfs(x,y):
    visited={(0,x,y)}
    dx=[0,0,1,-1]
    dy=[1,-1,0,0]
    queue=deque([(0,x,y)])
    while queue:
        time,x,y=queue.popleft()
        for i in range(4):
            nx,ny=x+dx[i],y+dy[i]
            temp=(time+1)%k
            if 0<=nx<r and 0<=ny<c and (temp,nx,ny) not in visited:
                cur=maze[nx][ny]
                if cur=='E':
                    return time+1
                elif cur!='#' or temp==0:
                    queue.append((time+1,nx,ny))
                    visited.add((temp,nx,ny))
    return 'Oop!'
t=int(input())
for _ in range(t):
    r,c,k=map(int,input().split())
    maze=[list(input()) for _ in range(r)]
    for i in range(r):
        for j in range(c):
            if maze[i][j]=='S':
                print(bfs(i,j))
```

海贼王之伟大航路

```python
# 旅行商问题
def tsp(n,cost):
    # dp[mask][i]为从起始岛屿开始，经过mask表示的岛屿，最后停在岛屿i的最短时间
    dp=[[float('inf')]*(n+1) for _ in range(1<<n)]
    dp[1][1]=0
    # 使用二进制来表示每个岛屿是否访问
    for mask in range(1,1<<n):
        for u in range(1,n+1):
            if not (mask&(1<<(u-1))):
                continue
            # 尝试从所有其他岛屿v转移到岛屿u
            for v in range(1,n+1):
                if mask&(1<<(v-1)) and u!=v:
                     # 对于每一个mask，我们可以从v岛前往u岛，并更新dp[mask][u]的值。
                    dp[mask][u]=min(dp[mask][u],dp[mask^(1<<(u-1))][v]+cost[v][u])
    return dp[(1<<n)-1][n]
n=int(input())
cost=[[0]*(n+1)]
for _ in range(n):
    row=[0]+list((map(int,input().split())))
    cost.append(row)
print(tsp(n,cost))
```

roads

```python
# 有限制的加权图最短路径问题
# Dijkstra算法
import heapq
def dijkstra(k,n,roads):
    graph=[[] for _ in range(n+1)]
    for road in roads:
        s,d,l,t=road
        graph[s].append((d,l,t))
    # dist[i][j]表示到达城市i且支付了j个硬币时的最短距离
    dist=[[float('inf')]*(k+1) for _ in range(n+1)]
    dist[1][0]=0
    #  优先队列
    queue=[(0,1,0)]
    while queue:
        # 选择最短距离的未访问节点
        distance,node,toll=heapq.heappop(queue)
        if node==n:
            return distance
        for next_node,length,cost in graph[node]:
            new_toll=toll+cost
            new_distance=distance+length
            # 更新邻居节点的距离
            if new_toll<=k and new_distance<dist[next_node][new_toll]:
                dist[next_node][new_toll]=new_distance
                heapq.heappush(queue,(new_distance,next_node,new_toll))
    return -1
k=int(input())
n=int(input())
r=int(input())
roads=[tuple(map(int,input().split())) for _ in range(r)]
print(dijkstra(k,n,roads))
```

## 树

括号嵌套树

```python
def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():
            node = TreeNode(char)
            if stack:
                stack[-1].children.append(node)
        elif char == '(':
            if node:
                stack.append(node)
            node = None
        elif char == ')':
            if stack:
                node = stack.pop()
    return node
```

哈夫曼树

```python
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap = []
    for char, weight in characters.items():
        heapq.heappush(heap, Node(weight, char))
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.weight + right.weight)
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)
    return heap[0]

def encode_huffman_tree(root):
    codes = {}
    def traverse(node, code):
        if node.char:
            codes[node.char] = code
        else:
            traverse(node.left, code + '0')
            traverse(node.right, code + '1')
    traverse(root, '')
    return codes

def huffman_encoding(codes, string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root, encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right
        if node.char:
            decoded += node.char
            node = root
    return decoded
```

树的转换

```python
def tree_heights(s):
    old_height, max_old, new_height, max_new = 0, 0, 0, 0
    stack = []
    for c in s:
        if c == 'd':
            old_height += 1
            max_old = max(max_old, old_height)
            new_height += 1
            stack.append(new_height)
            max_new = max(max_new, new_height)
        else:
            old_height -= 1
            new_height = stack[-1]
            stack.pop()
    return f"{max_old} => {max_new}"
```

树的直径

```python
def diameterOfBinaryTree(root):
    diameter = [0]
    def depth(node):
        if not node:
            return 0
        left_depth = depth(node.left)
        right_depth = depth(node.right)
        diameter[0] = max(diameter[0], left_depth + right_depth)
        return max(left_depth, right_depth) + 1
    depth(root)
    return diameter[0]
```

树的子结构

```python
def isSubtree(s, t):
    if not s:
        return False
    if isSameTree(s, t):
        return True
    return isSubtree(s.left, t) or isSubtree(s.right, t)
def isSameTree(s, t):
    if not s and not t:
        return True
    if not s or not t:
        return False
    if s.val != t.val:
        return False
    return isSameTree(s.left, t.left) and isSameTree(s.right, t.right)
```



## 图论

**经典类**

```python
class Vertex:	
    def __init__(self, key):
        self.id = key
        self.connectedTo = {}
		self.dist = sys.maxsize
        self.pred = None
    
    def addNeighbor(self, nbr, weight=0):
        self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + ' connectedTo: ' + str([x.id for x in self.connectedTo])

    def getConnections(self):
        return self.connectedTo.keys()

    def getId(self):
        return self.id

    def getWeight(self, nbr):
        return self.connectedTo[nbr]
    
    def __lt__(self, other):
        return self.distance < other.distance
```

```python
class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0
    
    def addVertex(self, key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex

    def getVertex(self, n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self, n):
        return n in self.vertList

    def addEdge(self, f, t, weight=0):
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], weight)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())
```

```python
def constructLaplacianMatrix(n, edges):
    graph = Graph()
    for i in range(n):
        graph.addVertex(i)

    for edge in edges:
        a, b = edge
        graph.addEdge(a, b)
        graph.addEdge(b, a)

    laplacianMatrix = []
    for vertex in graph:
        row = [0] * n
        row[vertex.getId()] = len(vertex.getConnections())
        for neighbor in vertex.getConnections():
            row[neighbor.getId()] = -1
        laplacianMatrix.append(row)

    return laplacianMatrix
```

**强连通单元**

**Kosaraju算法**

```python
def dfs1(graph, node, visited, stack):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs1(graph, neighbor, visited, stack)
    stack.append(node)

def dfs2(graph, node, visited, component):
    visited[node] = True
    component.append(node)
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs2(graph, neighbor, visited, component)

def kosaraju(graph):
    # Step 1: Perform first DFS to get finishing times
    stack = []
    visited = [False] * len(graph)
    for node in range(len(graph)):
        if not visited[node]:
            dfs1(graph, node, visited, stack)
    
    # Step 2: Transpose the graph
    transposed_graph = [[] for _ in range(len(graph))]
    for node in range(len(graph)):
        for neighbor in graph[node]:
            transposed_graph[neighbor].append(node)
    
    # Step 3: Perform second DFS on the transposed graph to find SCCs
    visited = [False] * len(graph)
    sccs = []
    while stack:
        node = stack.pop()
        if not visited[node]:
            scc = []
            dfs2(transposed_graph, node, visited, scc)
            sccs.append(scc)
    return sccs
```

**Tarjan算法**

```python
def tarjan(graph):
    def dfs(node):
        nonlocal index, stack, indices, low_link, on_stack, sccs
        index += 1
        indices[node] = index
        low_link[node] = index
        stack.append(node)
        on_stack[node] = True
        
        for neighbor in graph[node]:
            if indices[neighbor] == 0:  # Neighbor not visited yet
                dfs(neighbor)
                low_link[node] = min(low_link[node], low_link[neighbor])
            elif on_stack[neighbor]:  # Neighbor is in the current SCC
                low_link[node] = min(low_link[node], indices[neighbor])
        
        if indices[node] == low_link[node]:
            scc = []
            while True:
                top = stack.pop()
                on_stack[top] = False
                scc.append(top)
                if top == node:
                    break
            sccs.append(scc)
    
    index = 0
    stack = []
    indices = [0] * len(graph)
    low_link = [0] * len(graph)
    on_stack = [False] * len(graph)
    sccs = []
    
    for node in range(len(graph)):
        if indices[node] == 0:
            dfs(node)
    
    return sccs
```

**最短路径**

**Dijkstra算法**：用于在加权图中找到一个顶点到其他所有顶点的最短路径。

```python
import heapq
def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    return distances
```

**Floyd-Warshall算法**

```python
def floyd_warshall(graph):
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif j in graph[i]:
                dist[i][j] = graph[i][j]

    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist
```

**有额外限制的最短路径**

道路

```python
import heapq

K, N, R = map(int, [input() for _ in range(3)])
graph = {i: [] for i in range(1, N+1)}
visited = {i: float('inf') for i in range(1, N+1)}
for _ in range(R):
    S, D, L, T = map(int, input().split())
    graph[S].append((D, L, T))

queue, ans = [(0, 0, 1)], -1
while queue:
    l, t, s = heapq.heappop(queue)
    if s == N:
        ans = l
        break
    visited[s] = t
    for d, z, w in graph[s]:
        if t+w < visited[d] and t+w <= K:
            heapq.heappush(queue, (l+z, t+w, d))
print(ans)
```

**最小生成树问题**

**Kruskal算法**: 适合处理稀疏图，遵循贪心策略

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))  # 初始化每个顶点的父节点为自己
        self.rank = [0] * size  # 初始化树的高度
    def find(self, x):
        # 寻找根节点，并进行路径压缩
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    def union(self, x, y):
        # 合并两个集合
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1
```

```python
def kruskal(graph_edges, num_vertices):
    # graph_edges 是边的列表，每个元素是一个元组 (weight, vertex1, vertex2)
    # 按照边的权重从小到大排序
    graph_edges.sort()
    uf = UnionFind(num_vertices)  # 初始化并查集
    mst = []  # 用来存储最小生成树的边
    for weight, u, v in graph_edges:
        # 如果加入这条边不会形成环
        if uf.find(u) != uf.find(v):
            uf.union(u, v)  # 合并两个集合
            mst.append((u, v, weight))  # 加入到最小生成树中
    return mst
```

**Prim算法：**适合处理稠密图

```python
import heapq
def prim(graph, start_vertex):
    # graph 是一个字典，键是顶点，值是一个列表，列表中的元素是(邻居, 权重)
    mst = []  # 存储最小生成树的边
    visited = set([start_vertex])  # 已访问的顶点
    edges = [(weight, start_vertex, to) for to, weight in graph[start_vertex]]  # 从起始顶点出发的边
    heapq.heapify(edges)  # 将边转换成最小堆，以便高效地获取最小边
    while edges:
        weight, frm, to = heapq.heappop(edges)  # 获取权重最小的边
        if to not in visited:
            visited.add(to)  # 标记为已访问
            mst.append((frm, to, weight))  # 加入到最小生成树中
            for next_to, next_weight in graph[to]:
                if next_to not in visited:
                    heapq.heappush(edges, (next_weight, to, next_to))  # 将与新顶点相连的边加入堆中
    return mst

def prim(graph,start):
    pq = PriorityQueue()
    for vertex in graph:
        vertex.distance = sys.maxsize
        vertex.previous = None
    start.distance = 0
    pq.buildHeap([(v.distance,v) for v in graph])
    while pq:
        distance, current_v = pq.delete()
        for next_v in current_v.get_eighbors():
          new_distance = current_v.get_neighbor(next_v)
          if next_v in pq and new_distance < next_v.distance:
              next_v.previous = current_v
              next_v.distance = new_distance
              pq.change_priority(next_v,new_distance)
```

**最大流问题**

**Ford-Fulkerson 算法**

```python
# 使用邻接表表示图
class Graph:
    def __init__(self, graph):
        self.graph = graph  # 原始图
        self.ROW = len(graph)
        self.col = len(graph[0])
    # 使用DFS寻找从给定源到汇的路径，并存储路径，如果找到则返回True
    def dfs(self, s, t, parent):
        visited = [False] * self.ROW
        stack = []
        stack.append(s)
        visited[s] = True
        while stack:
            u = stack.pop()
            for ind, val in enumerate(self.graph[u]):
                if visited[ind] is False and val > 0:
                    stack.append(ind)
                    visited[ind] = True
                    parent[ind] = u
                    if ind == t:
                        return True
        return False
    # 使用Ford-Fulkerson算法返回图中从s到t的最大流量
    def fordFulkerson(self, source, sink):
        parent = [-1] * self.ROW
        max_flow = 0  # 最初最大流量为0
        # 增加流量只要能找到增广路径
        while self.dfs(source, sink, parent):
            path_flow = float("Inf")
            s = sink
            while (s != source):
                path_flow = min(path_flow, self.graph[parent[s]][s])
                s = parent[s]
            # 更新残余容量
            v = sink
            while (v != source):
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]
            max_flow += path_flow
        return max_flow
```

**图着色问题**

```python
def graph_coloring(graph):
    result = {}
    for node in sorted(graph, key=lambda x: len(graph[x]), reverse=True):
        neighbor_colors = {result[neighbor] for neighbor in graph[node] if neighbor in result}
        color = 1
        while color in neighbor_colors:
            color += 1
        result[node] = color
    return result
```

**拓扑排序（判断环）**

```python
from collections import deque
def topological_sort(graph):
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    queue = deque([u for u in in_degree if in_degree[u] == 0])
    visited = 0
    top_order = []
    while queue:
        u = queue.popleft()
        top_order.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
        visited += 1
    if visited != len(graph):
        return []
    return top_order
```

```python
def CheckCycle(graph):
    color = [0 for _ in range(N+1)]
    def dfs(x):
        color[x] = 1
        for i in graph[x]:
            if color[i] == 1:
                return True
            elif not color[i] and dfs(i):
                return True
        color[x] = 2
        return False

    for i in range(1, N+1):
        if not color[i]:
            if dfs(i):
                return True
    return False
```

词梯

```python
from collections import defaultdict, deque
from itertools import permutations

bucket = defaultdict(list)
n = int(input())
for o in range(n):
    word = input()
    for i in range(4):
        label = list(word)
        label[i] = '_'
        bucket[''.join(label)].append(word)

graph = defaultdict(list)
for words in bucket.values():
    for a, b in permutations(words, 2):
        graph[a].append(b)

start, end = input().split()
q = deque([start])
pre = dict()
used = set(q)

def bfs():
    while q:
        word = q.popleft()
        for nex in graph[word]:
            if nex not in used:
                used.add(nex)
                pre[nex] = word
                if nex == end:
                    return True
                q.append(nex)

res = bfs()
if res:
    ans = [end]
    while ans[-1] in pre:
        ans.append(pre[ans[-1]])
    print(*ans[::-1])
else:
    print('NO')
```

